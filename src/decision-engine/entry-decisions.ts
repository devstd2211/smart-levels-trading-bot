/**
 * Entry Decisions - Pure Decision Functions (Phase 0.3)
 *
 * Extracted decision logic from EntryOrchestrator.evaluateEntry()
 * Pure functions with NO side effects:
 * - No logger calls
 * - No service dependencies
 * - All inputs as parameters
 * - Deterministic output
 * - Testable in isolation
 */

import { Signal, Position, TrendAnalysis, FlatMarketResult } from '../types';
import { EntryDecision, SignalDirection } from '../types/enums';

// ============================================================================
// TYPES
// ============================================================================

/**
 * Context for entry decision - all data needed to decide ENTER/SKIP/WAIT
 */
export interface EntryDecisionContext {
  // Input signals
  signals: Signal[];

  // Account state
  accountBalance: number;
  openPositions: Position[];

  // Market context
  globalTrendBias: TrendAnalysis;
  flatMarketAnalysis?: FlatMarketResult;

  // Configuration
  minConfidenceThreshold: number; // 60 by default
  signalConflictThreshold: number; // 0.4 (40%) by default
  flatMarketConfidenceThreshold: number; // 70 by default
}

/**
 * Result of entry decision
 */
export interface EntryDecisionResult {
  decision: EntryDecision;
  reason: string;
  selectedSignal?: Signal;
  conflictAnalysis?: {
    conflictLevel: number;
    consensusStrength: number;
    direction: 'LONG' | 'SHORT' | 'NONE';
  };
}

// ============================================================================
// PURE DECISION FUNCTION
// ============================================================================

/**
 * PURE FUNCTION: Evaluate entry signals and decide ENTER/SKIP/WAIT
 *
 * Extracted from EntryOrchestrator.evaluateEntry()
 * Contains ONLY decision logic, NO side effects
 *
 * Decision process:
 * 1. Validate inputs (FAST FAIL)
 * 2. Filter signals by minimum confidence
 * 3. Detect signal conflicts (consensus analysis)
 * 4. Check flat market conditions
 * 5. Check trend alignment
 * 6. Return final decision
 *
 * Risk checks (RiskManager call) are NOT included here
 * Filter checks (FilterOrchestrator) are NOT included here
 * Those are orchestrator responsibilities, not pure decision logic
 */
export function evaluateEntry(context: EntryDecisionContext): EntryDecisionResult {
  // =====================================================================
  // STEP 0: Validate inputs (FAST FAIL)
  // =====================================================================
  if (!context.signals || context.signals.length === 0) {
    return {
      decision: EntryDecision.SKIP,
      reason: 'No signals generated by strategies',
    };
  }

  if (context.accountBalance <= 0) {
    return {
      decision: EntryDecision.SKIP,
      reason: `Invalid account balance: ${context.accountBalance}`,
    };
  }

  // =====================================================================
  // STEP 1: Filter signals by minimum confidence (FAST FAIL)
  // =====================================================================
  const validSignals = filterSignalsByConfidence(
    context.signals,
    context.minConfidenceThreshold
  );

  if (validSignals.length === 0) {
    return {
      decision: EntryDecision.SKIP,
      reason: `All signals confidence < ${context.minConfidenceThreshold}%`,
    };
  }

  // =====================================================================
  // STEP 2: Analyze signal conflicts (detect market indecision)
  // =====================================================================
  const conflictAnalysis = analyzeSignalConflicts(
    validSignals,
    context.signalConflictThreshold
  );

  if (!conflictAnalysis.topSignal) {
    return {
      decision: EntryDecision.SKIP,
      reason: 'No clear top signal after conflict analysis',
      conflictAnalysis,
    };
  }

  // If too much conflict, WAIT instead of entering
  if (conflictAnalysis.shouldWait) {
    return {
      decision: EntryDecision.WAIT,
      reason: `Signal conflict too high (${Math.round(
        conflictAnalysis.conflictLevel * 100
      )}%): ${conflictAnalysis.reasoning}`,
      conflictAnalysis,
    };
  }

  const topSignal = conflictAnalysis.topSignal;

  // =====================================================================
  // STEP 3: Check for flat/ranging market (potential chop)
  // =====================================================================
  if (context.flatMarketAnalysis) {
    if (
      context.flatMarketAnalysis.isFlat &&
      context.flatMarketAnalysis.confidence >= context.flatMarketConfidenceThreshold
    ) {
      return {
        decision: EntryDecision.SKIP,
        reason: `Flat market detected (${context.flatMarketAnalysis.confidence.toFixed(
          1
        )}% confidence) - no clear directional bias`,
        selectedSignal: topSignal,
        conflictAnalysis,
      };
    }
  }

  // =====================================================================
  // STEP 4: Check trend alignment (CRITICAL: no optional!)
  // =====================================================================
  const trendCheck = checkTrendAlignment(topSignal, context.globalTrendBias);
  if (!trendCheck.aligned) {
    return {
      decision: EntryDecision.SKIP,
      reason: `Trend misalignment: ${trendCheck.reason}`,
      selectedSignal: topSignal,
      conflictAnalysis,
    };
  }

  // =====================================================================
  // ALL CHECKS PASSED - APPROVE ENTRY
  // =====================================================================
  return {
    decision: EntryDecision.ENTER,
    reason: `${topSignal.type} @ ${topSignal.confidence.toFixed(
      1
    )}% (${conflictAnalysis.direction} consensus, confidence: ${Math.round(
      conflictAnalysis.consensusStrength * 100
    )}%)`,
    selectedSignal: topSignal,
    conflictAnalysis,
  };
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Filter signals by minimum confidence threshold
 * @private
 */
function filterSignalsByConfidence(
  signals: Signal[],
  minConfidence: number
): Signal[] {
  return signals.filter((signal) => {
    // Validate confidence value
    if (
      signal.confidence === undefined ||
      signal.confidence < 0 ||
      signal.confidence > 100
    ) {
      return false;
    }
    return signal.confidence >= minConfidence;
  });
}

/**
 * Analyze signals for consensus/conflict
 * Returns top signal and conflict metrics
 * @private
 */
function analyzeSignalConflicts(
  signals: Signal[],
  conflictThreshold: number
): {
  topSignal: Signal | null;
  conflictLevel: number;
  consensusStrength: number;
  shouldWait: boolean;
  reasoning: string;
  direction: 'LONG' | 'SHORT' | 'NONE';
} {
  if (signals.length === 0) {
    return {
      topSignal: null,
      conflictLevel: 0,
      consensusStrength: 0,
      shouldWait: false,
      reasoning: 'No signals available',
      direction: 'NONE',
    };
  }

  // Count votes by direction
  const longSignals = signals.filter((s) => s.direction === SignalDirection.LONG);
  const shortSignals = signals.filter(
    (s) => s.direction === SignalDirection.SHORT
  );

  const totalVotes = signals.length;

  // Only count LONG and SHORT for conflict (HOLD signals don't participate)
  const directionalVotes = longSignals.length + shortSignals.length;

  // If all HOLD, no direction
  if (directionalVotes === 0) {
    return {
      topSignal: null,
      conflictLevel: 0,
      consensusStrength: 0,
      shouldWait: false,
      reasoning: 'All signals are HOLD (no direction)',
      direction: 'NONE',
    };
  }

  // Calculate conflict metrics
  const minorityVotes = Math.min(longSignals.length, shortSignals.length);
  const conflictLevel = minorityVotes / directionalVotes;

  const majorityVotes = Math.max(longSignals.length, shortSignals.length);
  const consensusStrength = majorityVotes / directionalVotes;

  // Determine direction and whether to wait
  let topSignal: Signal | null = null;
  let shouldWait = false;
  let reasoning = '';
  let direction: 'LONG' | 'SHORT' | 'NONE' = 'NONE';

  if (conflictLevel >= conflictThreshold) {
    // HIGH CONFLICT: Too many opposing signals
    shouldWait = true;
    reasoning = `CONFLICT DETECTED: ${longSignals.length} LONG vs ${shortSignals.length} SHORT (${Math.round(
      conflictLevel * 100
    )}% conflict). Signals disagree too much, waiting for clarity.`;
    direction = 'NONE';
    // Still select a top signal for context (highest confidence overall)
    topSignal = signals.sort((a, b) => b.confidence - a.confidence)[0];

  } else if (longSignals.length > shortSignals.length) {
    // LONG consensus
    direction = 'LONG';
    topSignal = longSignals.sort((a, b) => b.confidence - a.confidence)[0];
    reasoning = `LONG consensus: ${longSignals.length}/${totalVotes} signals (conflict: ${Math.round(
      conflictLevel * 100
    )}%)`;

  } else if (shortSignals.length > longSignals.length) {
    // SHORT consensus
    direction = 'SHORT';
    topSignal = shortSignals.sort((a, b) => b.confidence - a.confidence)[0];
    reasoning = `SHORT consensus: ${shortSignals.length}/${totalVotes} signals (conflict: ${Math.round(
      conflictLevel * 100
    )}%)`;

  } else {
    // Equal votes (e.g., 2 LONG, 2 SHORT) - NO CONSENSUS
    shouldWait = true;
    reasoning = `NO CONSENSUS: ${longSignals.length} LONG = ${shortSignals.length} SHORT. Equal votes, no clear direction.`;
    direction = 'NONE';
    // Still select a top signal for context (highest confidence overall)
    topSignal = signals.sort((a, b) => b.confidence - a.confidence)[0];
  }

  return {
    topSignal,
    conflictLevel,
    consensusStrength,
    shouldWait,
    reasoning,
    direction,
  };
}

/**
 * Check if signal aligns with current trend
 * Returns { aligned: boolean, reason: string }
 * @private
 */
function checkTrendAlignment(
  signal: Signal,
  trend: TrendAnalysis
): { aligned: boolean; reason: string } {
  // NEUTRAL trend allows all directions
  if (trend.bias === 'NEUTRAL') {
    return {
      aligned: true,
      reason: 'Neutral trend allows both directions',
    };
  }

  // BEARISH trend: only SHORT allowed
  if (trend.bias === 'BEARISH') {
    if (signal.direction === SignalDirection.LONG) {
      return {
        aligned: false,
        reason: 'LONG blocked in BEARISH trend',
      };
    }
    return {
      aligned: true,
      reason: 'SHORT aligned with BEARISH trend',
    };
  }

  // BULLISH trend: only LONG allowed
  if (trend.bias === 'BULLISH') {
    if (signal.direction === SignalDirection.SHORT) {
      return {
        aligned: false,
        reason: 'SHORT blocked in BULLISH trend',
      };
    }
    return {
      aligned: true,
      reason: 'LONG aligned with BULLISH trend',
    };
  }

  // Unknown bias
  return {
    aligned: false,
    reason: `Unknown trend bias: ${trend.bias}`,
  };
}
