/**
 * Entry Orchestrator - PHASE 4 PRIMARY LAYER (Week 2)
 *
 * Single decision point for ALL entry decisions.
 * Consolidates:
 * - EntryScanner (primary logic)
 * - FastEntryService (alternative path) ‚Üí DEPRECATED
 * - EntryConfirmationManager (integrate as filter)
 * - StrategyCoordinator (move evaluation here)
 *
 * SINGLE RESPONSIBILITY:
 * Evaluate signals and determine: ENTER / SKIP / WAIT
 *
 * ATOMIC OPERATIONS:
 * All entry checks happen in one call:
 * 1. Get signals from strategies
 * 2. Rank by confidence (highest first)
 * 3. Check trend alignment (PHASE 4 rule)
 * 4. Call RiskManager for approval
 * 5. Return ENTER/SKIP/WAIT decision
 *
 * INTEGRATION POINT:
 * Called by TradingOrchestrator.onCandleClosed() instead of FragmentedEntryServices
 * Result is final decision - orchestrator doesn't override.
 */

import {
  Signal,
  EntryDecision,
  EntryOrchestratorDecision,
  SignalDirection,
  TrendAnalysis,
  Position,
  LoggerService,
  FlatMarketResult,
  RiskManager,
} from '../types';
import { NeutralTrendStrengthFilter } from '../filters/neutral-trend-strength.filter';
import { FilterOrchestrator } from './filter.orchestrator';

// ============================================================================
// CONSTANTS (PHASE 4: NO FALLBACKS RULE)
// ============================================================================

// Minimum confidence threshold to consider a signal valid
const ENTRY_ORCHESTRATOR_MIN_CONFIDENCE = 60; // Increased from 30% - avoid weak reversals

// If multiple signals, prefer this many top signals for ranking
const ENTRY_ORCHESTRATOR_TOP_SIGNALS = 3;

// Confidence boost for multi-strategy agreement
const ENTRY_ORCHESTRATOR_CONFIDENCE_BOOST_FOR_AGREEMENT = 10;

// PHASE 1.3: Flat market blocking threshold
const FLAT_MARKET_CONFIDENCE_THRESHOLD = 70; // Block entries if flat confidence >= 70%

// ============================================================================
// ENTRY ORCHESTRATOR
// ============================================================================

export class EntryOrchestrator {
  constructor(
    private riskManager: RiskManager,
    private logger: LoggerService,
    private neutralTrendFilter?: NeutralTrendStrengthFilter,
    private filterOrchestrator?: FilterOrchestrator,
  ) {
    this.logger.info('üéØ EntryOrchestrator initialized (PHASE 4)');
  }

  /**
   * PRIMARY METHOD: Evaluate entry signals and decide ENTER/SKIP/WAIT
   * SINGLE atomic decision point for all entry logic
   *
   * @param signals - Array of entry signals from strategies
   * @param accountBalance - Current account balance
   * @param openPositions - Currently open positions (for risk checking)
   * @param globalTrendBias - Current trend from TrendAnalyzer (HH_HL/LH_LL/NEUTRAL) - REQUIRED!
   * @param flatMarketAnalysis - Market flatness detection (PHASE 1.3)
   * @returns EntryOrchestratorDecision with ENTER/SKIP/WAIT
   *
   * CRITICAL BUG FIX: globalTrendBias is now REQUIRED (not optional)
   * Previously, entries could be accepted before trend was determined
   * This prevents positions from being opened during initialization gap
   */
  async evaluateEntry(
    signals: Signal[],
    accountBalance: number,
    openPositions: Position[],
    globalTrendBias: TrendAnalysis,  // REQUIRED - no longer optional!
    flatMarketAnalysis?: FlatMarketResult,
  ): Promise<EntryOrchestratorDecision> {
    try {
      // =====================================================================
      // PHASE 4 RULE: Validate inputs (FAST FAIL)
      // =====================================================================
      if (!signals || signals.length === 0) {
        return {
          decision: EntryDecision.SKIP,
          reason: 'No signals generated by strategies',
        };
      }

      if (accountBalance <= 0) {
        throw new Error(
          `[EntryOrchestrator] REQUIRED: accountBalance must be > 0. Got: ${accountBalance}`,
        );
      }

      // =====================================================================
      // STEP 1: Filter signals by minimum confidence (FAST FAIL)
      // =====================================================================
      const validSignals = signals.filter((signal) => {
        if (signal.confidence === undefined || signal.confidence < 0 || signal.confidence > 100) {
          this.logger.warn('Invalid signal confidence', {
            signal: signal.type,
            confidence: signal.confidence,
          });
          return false;
        }
        return signal.confidence >= ENTRY_ORCHESTRATOR_MIN_CONFIDENCE;
      });

      if (validSignals.length === 0) {
        this.logger.debug('All signals rejected: confidence below minimum', {
          minConfidence: ENTRY_ORCHESTRATOR_MIN_CONFIDENCE,
          totalSignals: signals.length,
        });
        return {
          decision: EntryDecision.SKIP,
          reason: `All signals confidence < ${ENTRY_ORCHESTRATOR_MIN_CONFIDENCE}%`,
        };
      }

      // =====================================================================
      // STEP 1.5: Check for flat market (PHASE 1.3 - NEW)
      // =====================================================================
      if (flatMarketAnalysis) {
        if (flatMarketAnalysis.isFlat && flatMarketAnalysis.confidence >= FLAT_MARKET_CONFIDENCE_THRESHOLD) {
          this.logger.warn('üö´ Entry blocked: Flat/ranging market detected', {
            flatConfidence: flatMarketAnalysis.confidence.toFixed(1) + '%',
            threshold: FLAT_MARKET_CONFIDENCE_THRESHOLD + '%',
            reason: 'No clear directional bias - high risk of chop',
            factors: flatMarketAnalysis.factors,
          });
          return {
            decision: EntryDecision.SKIP,
            reason: `Flat market detected (${flatMarketAnalysis.confidence.toFixed(1)}% confidence) - no clear directional bias`,
          };
        }

        if (flatMarketAnalysis.isFlat && flatMarketAnalysis.confidence >= FLAT_MARKET_CONFIDENCE_THRESHOLD * 0.7) {
          // Soft warning if approaching threshold
          this.logger.debug('‚ö†Ô∏è Market approaching flat state', {
            flatConfidence: flatMarketAnalysis.confidence.toFixed(1) + '%',
            threshold: FLAT_MARKET_CONFIDENCE_THRESHOLD + '%',
            note: 'Proceeding with caution',
          });
        }
      }

      // =====================================================================
      // STEP 2: Rank signals by confidence (highest first)
      // =====================================================================
      const rankedSignals = this.rankSignalsByConfidence(validSignals);
      const topSignal = rankedSignals[0];

      this.logger.debug('üìä Signals ranked by confidence', {
        topSignal: topSignal.type,
        topConfidence: topSignal.confidence.toFixed(1) + '%',
        totalValid: rankedSignals.length,
      });

      // =====================================================================
      // STEP 3: Check trend alignment (PHASE 4 RULE)
      // CRITICAL: Always check trend alignment (not optional!)
      // Bug fix: prevents entries before trend is determined
      // =====================================================================
      const trendCheck = this.checkTrendAlignment(topSignal, globalTrendBias);
      if (!trendCheck.aligned) {
        this.logger.info('‚ùå Signal blocked by trend alignment', {
          signal: topSignal.type,
          direction: topSignal.direction,
          trend: globalTrendBias.bias,
          reason: trendCheck.reason,
        });
        return {
          decision: EntryDecision.SKIP,
          reason: `Trend misalignment: ${trendCheck.reason}`,
        };
      }

      this.logger.debug('‚úÖ Signal passed trend alignment check', {
        signal: topSignal.type,
        direction: topSignal.direction,
        trend: globalTrendBias.bias,
      });

      // =====================================================================
      // STEP 3.5: Check NEUTRAL trend strength (via filter class)
      // =====================================================================
      if (this.neutralTrendFilter) {
        const neutralCheck = this.neutralTrendFilter.evaluate(topSignal, globalTrendBias);
        if (!neutralCheck.allowed) {
          this.logger.info('‚ùå Signal blocked by NEUTRAL trend strength filter', {
            signal: topSignal.type,
            direction: topSignal.direction,
            reason: neutralCheck.reason,
          });
          return {
            decision: EntryDecision.SKIP,
            reason: `NEUTRAL trend filter: ${neutralCheck.reason}`,
          };
        }

        this.logger.debug('‚úÖ Signal passed NEUTRAL trend strength filter', {
          signal: topSignal.type,
          reason: neutralCheck.reason,
        });
      }

      // =====================================================================
      // STEP 3.6: Check centralized FilterOrchestrator (NEW PHASE 2)
      // =====================================================================
      if (this.filterOrchestrator) {
        const filterContext = {
          signal: topSignal,
          accountBalance,
          openPositions,
          marketData: { flatMarketAnalysis },
          fundingRate: undefined, // TODO: Add funding rate from market data
          lastTPTimestamp: undefined, // TODO: Add TP timestamp from position manager
        };

        const filterResult = this.filterOrchestrator.evaluateFilters(filterContext);

        if (!filterResult.allowed) {
          this.logger.info('üö´ Signal blocked by FilterOrchestrator', {
            signal: topSignal.type,
            direction: topSignal.direction,
            blockedBy: filterResult.blockedBy,
            reason: filterResult.reason,
            appliedFilters: filterResult.appliedFilters.join(', '),
          });
          return {
            decision: EntryDecision.SKIP,
            reason: `Filter blocked: ${filterResult.reason || filterResult.blockedBy}`,
          };
        }

        this.logger.debug('‚úÖ Signal passed all FilterOrchestrator checks', {
          signal: topSignal.type,
          appliedFilters: filterResult.appliedFilters.join(', '),
        });
      }

      // =====================================================================
      // STEP 4: Call RiskManager for atomic approval
      // =====================================================================
      const riskDecision = await this.riskManager.canTrade(
        topSignal,
        accountBalance,
        openPositions,
      );

      if (!riskDecision.allowed) {
        this.logger.warn('‚ùå Trade blocked by RiskManager', {
          signal: topSignal.type,
          reason: riskDecision.reason,
        });
        return {
          decision: EntryDecision.SKIP,
          reason: `Risk check failed: ${riskDecision.reason}`,
          riskAssessment: riskDecision,
        };
      }

      // =====================================================================
      // ALL CHECKS PASSED - APPROVE ENTRY
      // =====================================================================
      this.logger.info('‚úÖ Entry APPROVED by EntryOrchestrator', {
        signal: topSignal.type,
        direction: topSignal.direction,
        confidence: topSignal.confidence.toFixed(1) + '%',
        adjustedPositionSize: riskDecision.adjustedPositionSize?.toFixed(4),
      });

      return {
        decision: EntryDecision.ENTER,
        signal: topSignal,
        reason: `${topSignal.type} @ ${topSignal.confidence.toFixed(1)}% confidence`,
        riskAssessment: riskDecision,
      };
    } catch (error) {
      this.logger.error('EntryOrchestrator evaluation failed', {
        error: error instanceof Error ? error.message : String(error),
      });
      return {
        decision: EntryDecision.SKIP,
        reason: `Orchestrator error: ${error instanceof Error ? error.message : 'unknown'}`,
      };
    }
  }

  /**
   * Rank signals by confidence level (highest first)
   * In case of tie, prefer signals that agree on direction
   *
   * PHASE 4 RULE: NO FALLBACKS - All signals must have valid confidence
   */
  private rankSignalsByConfidence(signals: Signal[]): Signal[] {
    if (signals.length === 0) {
      return [];
    }

    // Count agreement (how many signals have same direction as top)
    const directionCounts = new Map<SignalDirection, number>();
    signals.forEach((s) => {
      const count = directionCounts.get(s.direction) || 0;
      directionCounts.set(s.direction, count + 1);
    });

    // Sort by: confidence DESC, then agreement count DESC
    return signals.sort((a, b) => {
      // Primary: Confidence (highest first)
      if (b.confidence !== a.confidence) {
        return b.confidence - a.confidence;
      }

      // Secondary: Direction agreement (more signals = better)
      const countA = directionCounts.get(a.direction) || 0;
      const countB = directionCounts.get(b.direction) || 0;
      return countB - countA;
    });
  }

  /**
   * Check if signal aligns with current trend
   *
   * Rules:
   * - BEARISH trend ‚Üí only SHORT allowed
   * - BULLISH trend ‚Üí only LONG allowed
   * - NEUTRAL trend ‚Üí both allowed
   *
   * PHASE 4 RULE: NO FALLBACKS
   */
  private checkTrendAlignment(
    signal: Signal,
    trend: TrendAnalysis,
  ): { aligned: boolean; reason: string } {
    // No restrictions if neutral
    if (trend.bias === 'NEUTRAL') {
      return {
        aligned: true,
        reason: 'Neutral trend allows both directions',
      };
    }

    // BEARISH: Block LONG
    if (trend.bias === 'BEARISH') {
      if (signal.direction === SignalDirection.LONG) {
        return {
          aligned: false,
          reason: 'LONG blocked in BEARISH trend',
        };
      }
      return {
        aligned: true,
        reason: 'SHORT aligned with BEARISH trend',
      };
    }

    // BULLISH: Block SHORT
    if (trend.bias === 'BULLISH') {
      if (signal.direction === SignalDirection.SHORT) {
        return {
          aligned: false,
          reason: 'SHORT blocked in BULLISH trend',
        };
      }
      return {
        aligned: true,
        reason: 'LONG aligned with BULLISH trend',
      };
    }

    // Unknown bias
    return {
      aligned: false,
      reason: `Unknown trend bias: ${trend.bias}`,
    };
  }
}
